# 谈谈变量提升
- 当js代码执行的时候，会产生执行环境，执行环境又分为全局执行环境和函数体执行环境，
  比如说，我定义一个全局变量a和一个函数b，在函数b里可以拿得到全局变量a，
  但如果我在全局变量a前面打印a，那么它就拿不到，但是它不会报错，
  会打印出来undefined,这就是因为我们声明的变量a它提升了，变量提升是声明提升，它的赋值不会提升，
  这就导致了它打印是undefined而不是Error报错，
  那如果我在我的函数体声明前面调用这个函数，函数体里面的console.log()能正常打印出来，
  这就是因为在js里面函数声明会整体提升，变量提升只有声明提升

# bind、call、apply区别
- 首先bind、call、apply都是未来解决this的指向问题的，
  作用都是相同的，只是传参方式不同，
  除了第一个参数以外(第一个参数都是传this)
  call可以接受一个参数列表，可以放很多个参数(任意个参数)
  apply只接受一个参数数组
  bind接受跟call一样(接受任意个参数)，但bind返回的是一个函数

# bind实现
- 就是用来改变this指向的，让新的对象可以执行该函数
- a.bind() 相当于把a的this绑定在window上
- a.bind(b) 相当于让a的this能够访问到b里面的内容
  其本质效果是把a这个函数放到b那个对象里面去，然后执行完之后，用b去调用a，然后把b里面的a给移除掉
- bind.js

# call、apply实现

# 简单聊一下原型链
- 每个函数都有prototype属性，除了function.prototype.bind这个属性指向原型，
  每个对象都有_proto属性，指向的是创建这个对象的一个构造函数的原型
  其实这个属性指向的是一个[[prototype]]，但是[[prototype]]是一个内部属性，我们是拿不到的，
  所以我们用_proto来访问，那对象可以通过_proto来寻找到不属于该对象的一个属性，
  _proto是将对象连接起来组成了原型链